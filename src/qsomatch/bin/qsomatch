#!/usr/bin/env ruby

require 'getoptlong'
require 'database'
require 'dxmap'
require 'bandmode'
require 'contestdb'
require 'callsign'
require 'addlog'
require 'cabrillo'
require 'qrzdb'
require 'crossmatch'
require 'singletons'
require 'calctimeadj'
require 'multiplier'
require 'report'
require 'errors'
require 'dumplog'
require 'json'


$year = nil
$name = nil
$explain = false
$totallydestroy = false
$skipclock = true
$restart = false
$create = false
$readinit = true
$action = nil
$qrzuser = nil
$qrzpwd = nil
$verbose = nil
ctl = CallsignTools.new

opts = GetoptLong.new(
                      [ '--new', '-N', GetoptLong::NO_ARGUMENT],
                      [ '--check', '-C', GetoptLong::NO_ARGUMENT],
                      [ '--check-dupe', '-c', GetoptLong::NO_ARGUMENT],
                      [ '--calc-clock-adj', '-x', GetoptLong::NO_ARGUMENT],
                      [ '--no-init', '-I', GetoptLong::NO_ARGUMENT],
                      [ '--qrzuser', '-u', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--exceptions', '-X', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--qrzpwd', '-p', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--sqlite', '-S', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--reset', '-R', GetoptLong::NO_ARGUMENT],
                      [ '--name', '-n', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--year', '-y', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--verbose', '-V', GetoptLong::NO_ARGUMENT],
                      [ '--load', '-l', GetoptLong::NO_ARGUMENT],
                      [ '--score', '-s', GetoptLong::NO_ARGUMENT],
                      [ '--rare', '-r', GetoptLong::NO_ARGUMENT],
                      [ '--fifty-eight', '-5', GetoptLong::NO_ARGUMENT],
                      [ '--report', '-T', GetoptLong::NO_ARGUMENT]
                      )

cmddbopts = Hash.new
opts.each { |opt, arg|
  case opt
  when '--new'
    $create = true
  when '--calc-clock-adj'
    $skipclock = false
  when '--no-init'
    $readinit = false
  when '--qrzuser'
    $qrzuser = arg
  when '--verbose'
    $verbose = true
  when '--qrzpwd'
    $qrzpwd = arg
  when '--sqlite'
    cmddbopts['type'] = 'sqlite3'
    cmddbopts['filename'] = arg
  when '--report'
    $action = :report
  when '--fifty-eight'
    $action = :fifty_eight
  when '--rare'
    $action = :rare
  when '--check'
    $action = :check
  when '--check-dupe'
    $action = :checkdupes
  when '--load'
    $action = :load
  when '--score'
    $action = :score
  when '--reset'
    $restart = true
  when '--name'
    $name = arg
  when '--year'
    $year = arg.to_i
  when '--exceptions'
    ctl.addException(arg.split(/[,;:]/))
  end
}
                      

if $readinit and ENV["HOME"] and File.readable?(ENV["HOME"] + File::SEPARATOR + ".qsomatch")
  require 'json'
  dbopts = JSON.load(File.read(ENV["HOME"] + File::SEPARATOR + ".qsomatch"))
else
  dbopts = { 'type' => 'sqlite3', 'filename' => 'qsomatch.db' }
end

dbopts.merge!(cmddbopts)

def loadFiles(args, cdb, contestID, ctl)
  args.each { |filename|
    begin
      cab = Cabrillo.new(filename)
      if cab and cdb
        addLog(cdb, contestID, cab, ctl)
      end
      if $action == :check
        if cab
          if not cab.cleanparse
            $stderr.flush
            $stdout.flush
            print "Station: #{cab.logcall}:#{filename} failed to parse.\n"
            $stdout.flush
          end
          if not cab.badmults.empty?
            $stderr.flush
            $stdout.flush
            print "Station: #{cab.logcall}:#{filename} has bad #{cab.badmults.size} multipliers in #{cab.qsos.size} QSO(s).\n"
            print "Multipliers: " + cab.badmults.to_a.join(" ") + "\n"
            $stdout.flush
          end
          if not cab.defaultSentQTH  or cab.defaultSentQTH == "CA"
            $stderr.flush
            $stdout.flush
            print "Station: #{cab.logcall}:#{filename} has bad sent QTH #{cab.defaultSentQTH} in the header\n"
            $stdout.flush
          end
          if not cab.badSentMults.empty?
            $stderr.flush
            $stdout.flush
            print "Station: #{cab.logcall}:#{filename} has bad sent QTHs in QSO lines: #{cab.badSentMults.to_a.join(" ")}\n"
            $stdout.flush
          end
        else
          $stderr.flush
          $stdout.flush
          print "#{filename} failed to parse at all.\n"
          $stdout.flush
        end
      end
    rescue ArgumentError => e
      $stderr.flush
      $stdout.flush
      print "#{filename} caused an exception #{e}\n"
      $stdout.flush
    end
  }
  if cdb
    cdb.checkDupeLogs(contestID)
  end
end

class AllIncluded
  def include?(str)
    true
  end

  def useQRZ?
    true
  end
end


def isDXCall(callsign)
  dm = CallsignLocator.new
  entity = dm.lookup(callsign)
  if entity
    return entity.dx?
  end
  false
end

def checkCallsigns(db, cid, user, pwd)
  if user and pwd
    qrz = QRZLookup.new(user, pwd)
  else
    qrz = nil
  end
  xmldb = readXMLDb()
  if File.readable?("valid1x1.json")
    validOneByOnes = Set.new(JSON.parse(File.read("valid1x1.json")))
    def validOneByOnes.useQRZ?
      false
    end
  else
    $stderr.write("Missing valid1x1.json\n")
    validOneByOnes = AllIncluded.new # says everything is valid
  end
  db.query("select id, basecall from Callsign where contestID = ? and validcall is null;", [cid.to_i]) { |row|
    if row[1].length > 3 or validOneByOnes.useQRZ?
      if xmldb.has_key?(row[1]) 
        db.query("update Callsign set validcall = ? where id = ? limit 1;",
                 [(xmldb[row[1]] ? 1 : 0), row[0].to_i])
      elsif lookupCall(qrz, xmldb, row[1])
        db.query("update Callsign set validcall = 1 where id = ? limit 1;",
                 [row[0].to_i])
      elsif isDXCall(row[1]) # QRZ is not a reliable authority for DX
        db.query("update Callsign set validcall = 1 where id = ? limit 1;",
                 [row[0].to_i])
      else
        db.query("update Callsign set validcall = 0 where id = ? limit 1;",
                 [row[0].to_i]);
        print "Callsign #{row[1]} is unknown to QRZ.\n"
      end
    else
      if validOneByOnes.include?(row[1])
        db.query("update Callsign set validcall = 1 where id = ? limit 1;",
                 [row[0].to_i]);
      else
        db.query("update Callsign set validcall = 0 where id = ? limit 1;",
                 [row[0].to_i]);
      end
    end
  }
  if File.readable?("illegalcalls.json")
    list = JSON.parse(File.read("illegalcalls.json"))
    list.each { |callsign|
      db.query("update Callsign set validcall = 0, illegalcall = 1 where basecall= ? limit 1;",
               [ callsign ])
    }
  else
    $stderr.write("Missing illegalcalls.json\n")
  end
end

NUMSECS=5
NUMDOTS=3
def restartContest(cm)
  print "Restarting in 5 seconds: "
  NUMSECS.times { |i|
    print (NUMSECS-i).to_s
    NUMDOTS.times { 
      sleep (1.0/NUMDOTS)
      print "."
      $stdout.flush
    }
  }
  print "0  Done.\n"
  $stdout.flush
  cm.restartMatch
end

def rareReport(db, contestID, contestDB)
  m = Multiplier.new(db, contestID, contestDB)
  m.rareMultReport
end

def report58(db, contestID, contestDB)
  r =Report.new(db, contestID)
  r.firstTo58($stdout, contestID)
end

def reportContest(db, contestID, contestDB)
  r = Report.new(db, contestID)
  dir = "cqp" + $year.to_s + "_reverse"
  begin
    Dir.mkdir(dir)
  rescue
    # ignore exception
  end
  print "Making reverse logs\n"
  r.makeReverseLogs(dir, contestID)
  print "Making general reports\n"
  open("scores_" + $name.gsub(/\s+/,"_") + "_" + $year.to_s + ".csv", "w:ascii") { |out|
    r.makeReport(out, contestID)
  }
  open("green_" + $name.gsub(/\s+/,"_") + "_" + $year.to_s + ".txt", "w:ascii") { |out|
    r.makeGreenReport(out, contestID)
  }
  open("toxic_" + $name.gsub(/\s+/,'_') + "_" + $year.to_s + ".csv", "w:ascii") { |out|
    r.toxicLogReport(out, contestID)
  }
  dir = "cqp" + $year.to_s + "_lcrs"
  begin
    Dir.mkdir(dir)
  rescue
    # ignore exceptions
  end
  r.logCheckReport(dir, contestID)
  print "Dumping logs\n"
  dumpLogs(db, contestID)
  print "All Done Reporting\n"
end

def scoreContest(db, contestID, contestDB)
  cm = CrossMatch.new(db, contestID, contestDB)
  if $restart
    restartContest(cm)
  end
  checkCallsigns(db, contestID, $qrzuser, $qrzpwd)
  num1, dupeCount = cm.perfectMatch
  print "Perfect matches: #{num1} (dupes #{dupeCount})\n"
  $stdout.flush
  num1, dupeCount = cm.perfectMatch(CrossMatch::PERFECT_TIME_MATCH,
                                    "Partial", 
                                    :one)
  print "Perfect matches (with a band or mode mismatch): #{num1} (dupes #{dupeCount})\n"
  num3, partial, dupeCount  = cm.partialMatch
  print "Full matches partial: #{num3}\n"
  print "Partial matches full: #{partial}\n"
  print "               Dupes: #{dupeCount}\n"
  $stdout.flush
  num1, dupeCount = cm.perfectMatch(CrossMatch::MAXIMUM_TIME_MATCH, 'TimeShiftFull')
  print "Time shifted perfect matches: #{num1} (dupes #{dupeCount})\n"
  $stdout.flush
  num3, partial, dupeCount = cm.partialMatch(CrossMatch::MAXIMUM_TIME_MATCH, 'TimeShiftFull', 'TimeShiftPartial')
  print "Time shifted full matches partial: #{num3}\n"
  print "Time shifted partial matches full: #{partial}\n"
  print "                            Dupes: #{dupeCount}\n"
  $stdout.flush
  num1, dupeCount = cm.perfectMatch(CrossMatch::NOBANDMODE_TIME_MATCH,
                                    "Partial", 
                                    nil)
  print "Perfect matches (without band or mode mismatch): #{num1} (dupes #{dupeCount})\n"
  num3, partial, dupeCount = cm.partialMatch(CrossMatch::PERFECT_TIME_MATCH,
                                             'Partial', 'Partial',
                                             :one)
  print "   One side match with band/mode mismatch: #{num3}\n"
  print "One size mismatch with band/mode mismatch: #{partial}\n"
  print "                                    Dupes: #{dupeCount}\n"
  $stdout.flush
  p1, p2, dupeCount = cm.basicMatch(CrossMatch::MAXIMUM_TIME_MATCH)
  print "Basic QSO matches within 24 hours: #{p1+p2} (dupes #{dupeCount})\n"
  $stdout.flush
  cm.probMatch
  ct = CalcTimeAdj.new(db, contestID)
  if not $skipclock
    print "Calculating clock drift\n"
    ct.buildVariables
    ct.buildMILP
    print "Building matrix\n"
    ct.buildMatrix
    open("clock_report1.csv", "w:ascii") { |outfile|
      ct.report(outfile)
    }
    ct.buildMatrix              # second time it knows the bad clocks
    open("clock_report2.csv", "w:ascii") { |outfile|
      ct.report(outfile)
    }
    ct.reportByLog
  end
  timeviolation = ct.markOutOfContest
  ct = nil
  print "QSOs outside contest time period: #{timeviolation}\n"
  $stdout.flush
  num1, num2 = cm.resolveShifted
  print "Time shift resolved #{num1} full and #{num2} partial\n"
  $stdout.flush
  d1 = cm.ignoreDups
  print "Duplicates of matches: #{d1}\n"
  nil1 = cm.markNIL
  print "Not In Log penalties: #{nil1}\n"
  singles = ResolveSingletons.new(db, contestID, contestDB)
  print "Resolving singletons\n"
  $stdout.flush
  singles.resolve
  m = Multiplier.new(db, contestID, contestDB)
  print "Checking that every QSO has an appropriate sent multiplier\n"
  count = m.checkSentMultIDs
  print "#{count} QSOs updated\n"
  print "Matched QSOs get the judged multipier of the sender\n"
  transferred = m.transferJudged
  print "#{transferred} multipliers assigned\n"
  print "Resolving DX\n"
  m.resolveDX
  print "Resolving bye multipliers\n"
  m.checkByeMultipliers
  m.savePrevious("callmults.json")
  print "Resolving band/mode mismatches\n"
  bmm = BandModeMismatch.new(db, contestID, contestDB)
  bmm.resolve
  print "Assigning initial scores to QSO(s)\n"
  cm.initialScore
  print "Final dupe check\n"
  num = singles.finalDupeCheck
  print "#{num} Dupe QSOs identified during final check\n."
  print "Filling in comments\n"
  fillInComment(db, contestID)
  print "All Done Scoring\n"
end

begin
  if $name and $year and [:load, :score, :checkdupes, :rare, :report, :fifty_eight ].include?($action)
    db = makeDB(dbopts)
    cdb = ContestDatabase.new(db, ctl)
    contestID = cdb.addOrLookupContest($name, $year, $create)
    if not contestID
      print "Unknown contest #{$name} #{$year}\n"
      db.close
      exit 2
    end
  else
    db = nil
    cdb = nil
    if [:load, :score, :checkdupes, :rare, :report, :fifty_eight ].include?($action)
      print "Load and score action require a database.\n"
      exit 2
    end
  end  
  case $action
  when :load, :check
    loadFiles(ARGV, cdb, contestID, ctl)
  when :score
    scoreContest(db, contestID, cdb)
    reportContest(db, contestID, cdb)
  when :report
    reportContest(db, contestID, cdb)
  when :fifty_eight
    report58(db, contestID, cdb)
  when :rare
    rareReport(db, contestID, cdb)
  when :checkdupes
    if cdb and contestID
      cdb.checkDupeLogs(contestID)
    else
      $stderr.write("Check dupes requires a database and contest ID.\n")
    end
  end
  print "Done...shutting down\n"
  $stdout.flush
rescue
  print "Exception thrown"
  $stdout.flush
  $stderr.print "Exception: " + $!.to_s + "\n"
  $stderr.print $!.backtrace.join("\n")
ensure
  if db 
    db.close
  end
end

